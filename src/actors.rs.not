use ::actix::prelude::*;
use bytes::buf::BufMut;
use bytes::{Bytes, BytesMut};
use std::collections::HashSet;
use std::fmt::Write;

use crate::parser::*;

pub struct TagStripper {
    pub tags: HashSet<Bytes>,
}

pub struct MetricMessage {
    pub name: &'static str,
    pub data: &'static [u8],
}

impl TagStripper {
    pub fn new(strings: Vec<String>) -> TagStripper {
        let mut tags: HashSet<Bytes> = HashSet::with_capacity(strings.len());
        for string in strings.iter() {
            tags.insert(Bytes::from(string.as_bytes()));
        }
        TagStripper { tags }
    }
}

impl Actor for TagStripper {
    type Context = Context<Self>;
}

impl Message for MetricMessage {
    type Result = ();
}

impl Handler<MetricMessage> for TagStripper {
    type Result = ();

    fn handle(&mut self, msg: MetricMessage, ctx: &mut Context<Self>) -> Self::Result {
        let mut buf = BytesMut::with_capacity(1024);
        let mut src = msg.data;
        buf.write_str(msg.name);
        match parse_tags(src) {
            Some((remaining, tags)) => {
                for (tag, value) in tags {
                    if !self.tags.contains(tag) {
                        buf.put(b',');
                        buf.copy_from_slice(tag);
                        buf.put(b'=');
                        buf.copy_from_slice(value);
                    }
                }
                src = remaining;
            }
            None => (),
        }
        match parse_fields(src) {
            Some((remaining, fields)) => {
                let mut delimit = b' ';
                for (field, value) in fields {
                    buf.put(delimit);
                    buf.copy_from_slice(field);
                    buf.put(b'=');
                    buf.copy_from_slice(value);
                    delimit = b',';
                }
                src = remaining;
            }
            None => (),
        }
        match parse_timestamp(src) {
            Some((_, timestamp)) => {
                buf.put(b' ');
                buf.copy_from_slice(timestamp);
            }
            None => (),
        }
        buf.put(b'\n');
        match String::from_utf8(buf.to_vec()) {
            Ok(s) => {
                println!("Processed: {}", s);
            }
            Err(_) => (),
        }
        ()
    }
}
